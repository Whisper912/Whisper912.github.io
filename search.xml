<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Servlet学习(5)-数据库访问]]></title>
    <url>%2FServlet%E5%AD%A6%E4%B9%A0(5)-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[JDBC APIJDBC API包含在JDK中，分为java.sql和javax.sql两个包。java.sql定义了访问数据库的接口和类。下面是一段访问数据库的实例代码： 1234Class.forName("com.mysql.cj.jdbc.Driver");Connection conn = DriverManger.getConnection("jdbc:mysql://localhost/student?serverTimezone=UTC","root","password");Statement stmt = conn.createStatement();ResultSet rs = stmt.executeQuery("select * from stu"); 如上所示，利用JDBC访问数据库需要四步： 调用Class类的forName()方法，加载JDBC驱动 调用DriverManager类的getConnection()方法，得到Connection对象 调用Connection对象的createStatement()方法，得到Statement对象 最后调用Statement对象的executeQuery()方法，得到ResultSet对象 加载并注册数据库驱动Driver接口java.sql.Driver是所有JDBC驱动程序需要实现的接口。这个接口不用我们自己来写，是提供给数据库厂商写的。下面列出了几种主要数据库的JDBC驱动的类名。 SQL Server2005com.microsoft.sqlserver.jdbc.SQLServerDriver Sql Server2000com.microsoft.jdbc.sqlserver.SQLServerDriver oracleoracle.jdbc.driver.OracleDriver mysqlcom.mysql.cj.jdbc.Driver Driver接口中提供了一个Connect()方法，用来建立到数据库的连接。我们编程时不需要直接访问这些实现了Driver接口的类，我们使用JDBC驱动管理器（DriverManager）注册每个驱动程序，使用DriverManager提供的方法建立数据库连接。而DriverManager的连接方法去调用这些驱动类的connect()方法建立数据库连接。 加载与注册JDBC驱动加载JDBC驱动是调用Class类的静态方法forName(),向其传递要加载的JDBC类名。在运行时，类加载器从CLASSPATH中定位加载JDBC驱动类，加载后，注册驱动类的一个实例。DriverManager类中所有方法都是静态的，它提供了registerDriver()方法注册驱动类的实例，这个方法也不用我们亲自来调用。因为实现Driver接口的驱动程序类包含了静态代码块，在这个静态代码块中会调用DriverManager.registerDriver()注册自身的一个实例。当这个驱动类被加载时（也就是调用Class.forName()时），类加载器会执行该类的静态代码块，从而注册驱动类的一个实例。 建立到数据库的连接调用DriverManager的getConnection()方法建立对数据库的连接，返回一个COnnection对象。DriverManager中提供三个重载的getConnection()方法，常用的一个如下：public static Connection getConnection(String url, String user, String password) throws SQLException该方法需要数据库的URL，用户名和密码名。常用JDBC URL格式如下： SQLServerjdbc:microsoft:sqlserver://localhost:1443;databasename=pubs Oraclejdbc:oracle:thin:@localhost:1521:ORCL Mysqljdbc:mysql://localhost:3306/databasename 访问数据库在java.sql中提供了3个接口，分别定义了对数据库调用的不同方式，Statement、PreparedStatement和CallableStatement。 Statement调用Connection对象的createConnection()方法创建了一个Statement对象。Statement对象用于执行静态的SQL语句。Statement接口中定义了下列方法用于执行SQL语句 ResultSet executeQuery(String sql) throws SQLException该方法执行一歌查询语句，返回一个ResultSet对象 int updateQuery(String sql) throws SQLException该方法执行INSERT、UPDATE或DELETE操作。也可以执行DDL操作，如CREATE TABLE。 boolean execute(String sql) throws SQLException该方法执行返回多个结果集的SQL语句，通常不用。 int[] executeBatch() throws SQLException该方法允许我们向数据库提交一批命令，一起执行。ResultSet调用Statement对象的executeQuery()方法创建了一个ResultSet对象。ResultSet对象以逻辑表格的形式封装了执行数据库操作的结果集。ResultSet对象维护了一个指向当前数据行的游标，初始时，游标在第一行之前，可以通过ResultSet对象的next()方法移动到游标下一行。boolean next() throws SQLException该方法移动游标到下一行，如果新数据行仍然有效，返回true。ResultSet中定义了许多方法获取当前行的数据： 这些方法提供了两组形式的调用：一种以列的索引号为参数（列的索引从1开始）；另一种以列名作为参数，例如对getString()方法如下： String getString(int columnIndex) throws SQLException String getString(String columnName) throws SQLException对于不知道要获取的列的数据类型，可以一律采用getString()PreparedStatement在程序中传递的SQL语句在执行前必须被预编译，然后才被数据库引擎执行。如果重复执行只有参数不同的SQL语句，较低效。如果需要用不同的参数多次执行同一个SQL语句，可以使用PreparedStatement对象。PreparedStatement接口继承自Statement接口。可以通过调用Connection对象的prepareStatement()方法得到PreparedStatement对象。PreparedStatement对象所代表的SQL语句中的参数用问号（?）表示，调用PreparedStatement对象的setXxx()方法设置参数。setXxx()方法有两个参数，第一个是要设置的参数的索引（从1开始），第二个是要设置的参数值。元数据在SQL中，用于描述数据库或者它的各组成部分之一的数据成为元数据。在java.sql包中提供了一个接口ResultSetMetaData，用于获取描述数据库表结构的元数据。可以调用ResultSet对象的getMetaData()方法获得ResultSetMetaData对象。ResultSetMetaData接口定义了如下常用方法： 在java.sql包中，还提供了 DatabaseMetaData接口用于获取数据库信息可以通过调用Connection对象的getMetaData()方法获取DatabaseMetaData对象 ParameterMetaData接口用于得到PreparedStatement对象中的参数类型和属性信息。调用PreparedStatement对象的getParameterMetaData()方法得到ParameterMetaData对象 事务处理事务是构成单个逻辑工作单元的操作集合。事务处理保证所有事务都作为一个工作单元来执行。当在一个事务中执行多个操作时，要么所有操作都被提交（commit），要么整个事务回滚（rollback）回最初的事务。一个Connection对象被创建时，默认是自动提交事务。为了将多个SQL语句作为一个事务执行，可以调用Connection对象的setAutoCommit()方法，传入false取消自动提交，然后在所有SQL语句执行成功后，调用Connection对象的commit()方法提交事务，或者在执行出错时调用Connection对象的rollback()方法。为了避免多个事务同时访问一份数据可能引发的冲突，我们需要设置事务的隔离级别。标准SQL定义了4种事务隔离级别： 在Connection接口中定义了setTransactionIsolation()方法设置事务隔离级别，Connection接口还设置了5个常量值用做setTransactionIsolation()方法的参数：]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet学习(4)-Web应用程序的部署]]></title>
    <url>%2FServlet%E5%AD%A6%E4%B9%A0(4)-Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[配置任意目录下的web应用程序一个web服务器可以部署多个web应用，每个web应用都有自己的唯一的上下文根。web服务器可以配置虚拟目录，在Tomcat中可以通过在配置文件中设置&lt;context&gt;元素完成。一个&lt;context&gt;元素就表示一个web应用，运行在特定虚拟机中。&lt;context&gt;元素常用属性如下： 在%CATALINA_HOME%\webapps目录下有个ROOT目录，Tomcat为ROOT目录生成的&lt;context&gt;元素上下文路径为空字符串(&quot;&quot;)。如果一个web应用的上下文路径为&quot;&quot;，那这个应用作为这个虚拟主机的默认web应用，所以访问http://localhost:8080/时，访问的是%CATALINA_HOME%\webapps\ROOT下的资源。在部署web应用时，我比较喜欢的做法是：在%CATALINA_HOME%\conf\Catalina\localhost下创建xml文件。例如你的上下文绝对路径为E:\WorkSpace\HelloWorld，就在%CATALINA_HOME%\conf\Catalina\localhost下新建HelloWorld.xml，用记事本打开HelloWorld.xml，在里面写 1&lt;Context path="/HelloWorld" reloadable="true" docBase="E:\WorkSpace\HelloWorld" /&gt; WAR文件我们可以将web应用打包成WAR文件，方便发布。步骤如下（以上面的HelloWorld为例）：进入web应用上下文目录（E:\WorkSpace\HelloWorld），打开命令提示行，执行以下命令jar -cvf HelloWorld.war *，然后将这个.war文件放入%CATALINA_HOME%\webapps下，Tomcat启动时会自动解压这个WAR文件 web.xml&lt;Servlet&gt;元素及其子元素图中*表示可以有0个或多个子元素，？表示可以有0个或1个，除此之外为必备的元素。 &lt;Servlet-mapping&gt;元素及其子元素&lt;servlet-mapping&gt;元素在Servlet和URL样式之间定义一个映射，它包含两个子元素&lt;servlet-name&gt;和&lt;url-pattern&gt;，同一个Servlet可以对应多个url。在配置了servlet和URL的映射之后，当Servlet容器收到一个请求，它首先应该确定由哪个web应用来响应，这时是通过对比URI的开始部分与所有web应用上下文确定的。确定了是哪个web应用后，要确定由哪个Servlet处理，映射到Servlet的路径是请求的URI去掉上下文路径，这时通过下面的规则匹配，如果找到第一个成功匹配的就不再进行下一个匹配。 在URL中，可以使用以下语法定义映射： 使用*匹配任意串 一个单独的/匹配web应用的默认servlet 未找到匹配的Servlet，则使用默认servlet]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Servlet学习(3)-Servlet异常、Servlet生命周期、ServletContext、请求转发]]></title>
    <url>%2FServlet%E5%AD%A6%E4%B9%A0(3)-Servlet%E5%BC%82%E5%B8%B8%E3%80%81Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81ServletContext%E3%80%81%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[Servlet异常在javax.servlet包中定义了两个异常类，ServletException和UnavailableException。 ServletExceptionServletException可以被init(), service(), doXxx()抛出，这个类提供了下面4个构造方法和1个实例方法： UnavailableExceptionUnavailableException是ServletException的子类，该异常呗Servlet抛出，用于指示这个Servlet永久不可用或者暂时不可用 Servlet生命周期Servlet运行在Servlet容器中，它的生命周期由容器来管理。Servlet的生命周期通过javax.servlet.Servlet接口中的init(), service(), destroy()表示。Servlet生命周期包含以下4个阶段： 加载和实例化Servlet容器负责加载和实例化Servlet。当Servlet容器启动时，或者容器检测到需要某个Servlet相应第一个请求时，创建该Servlet实例。 初始化Servlet实例化后，容器将调用Servlet的init()方法初始化该对象。初始化的目的是让Servlet对象在处理请求前完成一些初始化工作，如建立数据库连接、获取配置信息。对于每个Servlet实例，init()只被调用一次。初始化期间，Servlet实例可以使用Servlet提供的ServletConfig对象从web.xml中获取配置信息。 请求处理Servlet容器调用service()处理请求。需要注意，service()方法调用之前，init()方法必须成功执行。在service()方法中，Servlet对象通过ServletRequest对象获取请求数据，使用ServletResponse对象设置相应信息。service()期间，如果发生错误可以抛出ServletException和UnavailableException。若UnavailableException支出该实例永久不可用，则执行destroy(),之后的请求都会收到容器发送的HTTP404（请求的资源不可用）；若UnavailableException指出该Servlet实例暂时不可用，之后的请求都会收到容器发送的HTTP503（服务器暂时忙，不能处理请求） 服务终止当容器检测到某个Servlet实例应该从服务器中移除时，容器调用destroy()方法，使得Servlet实例释放它使用的资源。destroy()执行完毕后，容器释放该Servlet实例。如果之后再次需要这个Servlet处理请求，容器会创建一个新的实例。 另外，如果需要让Servlet容器在启动时即加载Servlet，可以在web.xml中配置&lt;load-on-startup&gt;元素 Servlet上下文运行在Java虚拟机中的每一个Web应用都有一个与之相关的Servlet上下文。Java Servlet API提供了ServletContext接口表示Servlet上下文。该接口中提供了一组方法，Servlet可以使用这些方法和容器通信。ServletContext对象是Web服务器中一个已知路径的根（项目根目录），ServletContext对象可以被同一个Web应用程序中的所有Servlet共同访问。 ServletContext接口可以通过ServletConfig对象的getServletContext()获取ServletContext对象。ServletContext接口定义了如下方法，容器实现了这些接口： 请求转发RequestDispatcher接口RequestDispatcher对象由容器创建，用于封装一个由路径标识的服务器资源。利用RequestDispatcher对象，可以把请求转发给其他Servlet或JSP页面。RequestDispatcher接口中定义了两种方法。 public void forward(ServletRequest request, ServletResponse res) throws ServletException,java.io.IOException public void include(ServletRequest request, ServletResponse res) throws ServletException,java.io.IOException两种方法的区别：利用include()方法将请求转发给其他Servlet时，被调用的Servlet对该请求做出的相应将追加入原先的相应中，原先的Servlet还可以继续输出相应信息；而利用forward()将请求转发给其他Servlet，会由被调用的Servlet对请求作出相应，原先的Servlet的执行终止。获取RequestDispatcher对象三种方法一种是使用ServletRequest接口public RequestDispatcher getRequestDispatcher(java.lang.String path)另外两种是使用ServletContext接口public RequestDispatcher getRequestDispatcher(java.lang.String path)public RequestDispatcher getNamedDispatcher(java.lang.String name)两个同名方法getRequestDispatcher()的区别是：ServletContext接口中的方法参数必须以斜杠（/)开始，解释为相对上下文的路径。而ServletRequest接口中的方法参数不但可以是相对上下文的（以斜杠开头），也可以是相对于当前Servlet（不以斜杠开头则被解释为相对于当前Servlet）。提示：使用ServletContext的getRequestDispatcher()得到的RequestDispatcher对象可以将请求转发到另一个web应用程序中的资源。但注意跨web应用时，需要在当前web应用程序的&lt;context&gt;元素的设置中，crossContext属性值为true。sendRedirect()和forward()的区别HttpServletResponse接口的sendRedirect()也可以完成请求转发，但和forward()有本质区别，他们的工作原理如下图：]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet生命周期</tag>
        <tag>ServletContext</tag>
        <tag>请求转发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet学习(2)-ServletAPI]]></title>
    <url>%2FServlet%E5%AD%A6%E4%B9%A0(2)-Servlet%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[Servlet APIServlet相关接口和类 Servlet接口 Java Servlet不是独立的应用程序，没有main()方法。 它不由用户或程序员直接调用，而是生存在容器中，由容器管理 要编写一个Servlet就要实现javax.servlet.Servlet接口，该接口中定义了5个方法。 12345678910public void init(ServletConfig config) throws ServletException//init()：在Servlet实例化后，Servlet容器会调用init方法来初始化该对象。对于每个Servlet实例，init()只能被调用一次。public void service(ServletRequest req, ServletResponse res) throws ServletException//service(): 容器调用servic()处理客户端发过来的请求。public void destroy()//destroy()：当某个Servlet对象不再使用了，容器调用destroy()释放资源。public ServletConfig getServletConfig()//返回init()传递给Servlet对象的ServletConfig对象。public java.lang.String getServletInfo()//返回Servlet信息 ServletRequst和ServletResponse因为Servlet是由Servlet容器来管理的，当客户端传来一个请求，Servlet容器会创建一个ServletRequest对象封装请求数据，同时创建一个ServletResponse对象封装响应数据。容器将这两个对象作为service()的参数传给Servlet，Servlet使用ServletRequest对象获取请求，利用ServletResponse对象发送响应。ServletRequest和ServletResponse接口定义在javax.servlet包中。 ServletRequest接口中的常用方法 ServletResponse接口中的常用方法 ServletConfig在javax.servlet包中还定义了ServletConfig接口。Servlet容器使用ServletConfig对象在初始化时向Servlet传递配置信息，一个Servlet只有一个ServletConfig对象。 ServletConfig接口中的常用方法 GenericServlet通过实现Servlet接口编写Servlet类非常麻烦，需要自己重写5个函数，为了简化编写，javax.servlet包中提供了抽象类GenericServlet，它给出了除了service()方法以外的其他方法的简单实现。GenericServlet定义了一个通用的、不依赖具体协议的Servlet，它实现了Servlet接口和ServletConfig接口。此时，我们编写Servlet时只需要继承GenericServlet，实现service()方法就行了。 HttpServlet为了快速开发基于http的Servlet类，javax.servlet.http包中提供了一个抽象类HttpServlet，它继承自GenericServlet。HttpServlet提供了两个重载的service()方法： 针对HTTP1.1的7种请求方法GET, POST, HEAD, PUT, DELETE, TRACE和OPTION，HttpServlet提供7个方法处理： 这7个方法的参数都是HttpServletRequest和HttpServletResponse类型，与第二个重载的service()方法相同。当容器收到一个针对HttpServlet的请求时，方法调用顺序如下： 调用继承过来的public service()方法 在public service()方法中，将ServletRequset和ServletResponse强转为HttpServletRequest和HttpServletResponse类型，并将转换后的参数作为重载的protected service()方法的参数传入，调用protected service()方法。 在protected service()方法中，先调用HttpServletRequest对象的getMethod()方法，获取HTTP请求的类型，根据不同类型调用不同的doXxx()方法。因此，在编写HttpServlet派生类时只需要重写相应的doXxx()方法，不用重写service()。 HttpServletRequest和HttpServletResponse在javax.servlet.http包中，定义了HttpServletRequest和HttpServletResponse这两个接口。他们分别继承自ServletRequest和ServletResponse接口。 HttpServletRequest接口中新增的方法 HttpServletResponse新增了一组静态常量表示HTTP错误代码，对应于HTTP1.1错误代码，具体可以查看HttpServletResponse接口的API文档。java ee文档地址在左上角选对应的包，左下角选择接口或类，就可以在右边查看相应API文档介绍]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet学习(1)-Servlet和Tomcat]]></title>
    <url>%2FServlet%E5%AD%A6%E4%B9%A0(1)-Servlet%E5%92%8CTomcat%2F</url>
    <content type="text"><![CDATA[Servlet学习系列基于孙鑫的《Servlet/JSP深入详解——基于Tomcat的Web开发》 Servlet和Servlet容器Servlet是一个基于java的web组件，有Servlet容器管理，用于生成动态页面。Servlet容器，也叫作Servlet引擎，是web服务器的一部分，用于在发送的请求和响应之上提供网络服务。Servlet不能独立运行，必须要由Servlet容器实例化并调用Servlet的方法，Servlet容器在servlet的生命周期内管理Servlet。也就是说，当用户在浏览器中输入网址请求页面，web服务器收到该请求后并不直接交给Servlet处理，而是交给Servlet容器。Servlet容器实例化Servlet并调用某个方法处理请求，并产生一个相应。然后Servlet容器将这个相应返回给web服务器，web服务器包装响应以HTTP响应的形式返回给web浏览器。 Tomcat简介使用Servlet，需要有Servlet容器，作者用的是Tomcat。Tomcat是个免费开源的Servlet容器，它支持Servlet和JSP。]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法-动态规划-最大子数组.md]]></title>
    <url>%2F%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目给一个数组，返回它的最大连续子序列的和。（ 例如{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。） 解法以下解法来源https://www.nowcoder.com/profile/844008/codeBookDetail?submissionId=1519441 @小新没有蜡笔~ 的解法使用动态规划F（i）：以array[i]为末尾元素的子数组的和的最大值，子数组的元素的相对位置不变F（i）=max（F（i-1）+array[i] ， array[i]）res：所有子数组的和的最大值res=max（res，F（i）） 如数组[6, -3, -2, 7, -15, 1, 2, 2]初始状态： F（0）=6 res=6i=1： F（1）=max（F（0）-3，-3）=max（6-3，3）=3 res=max（F（1），res）=max（3，6）=6i=2： F（2）=max（F（1）-2，-2）=max（3-2，-2）=1 res=max（F（2），res）=max（1，6）=6i=3： F（3）=max（F（2）+7，7）=max（1+7，7）=8 res=max（F（3），res）=max（8，6）=8i=4： F（4）=max（F（3）-15，-15）=max（8-15，-15）=-7 res=max（F（4），res）=max（-7，8）=8以此类推最终res的值为8 1234567891011public static int FindGreatestSumOfSubArray(int[] array) &#123; if(array==null) return 0; int sum=array[0]; int maxi=array[0]; //以array[i]为末尾元素的子数组的和的最大值 for(int i=1; i&lt;array.length; i++) &#123; maxi=array[i]&gt;maxi+array[i] ? array[i] : maxi+array[i]; sum=sum&gt;maxi ? sum:maxi; &#125; return sum;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-疯狂Java讲义-第7章-Java集合]]></title>
    <url>%2F%E7%AC%94%E8%AE%B0-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC7%E7%AB%A0-Java%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[概述为了保存数量不确定，且有映射关系的数据，java提供了集合类，都在java.util包下。集合里只能存放对象（的引用）。Java集合类主要由Collection和Map派生。 Collection派生的Set是无序集合（元素不可重复，只能根据元素本身访问），List是有序集合（元素可重复，类似于数组，访问时可以根据索引访问）。 Map集合存放的都是key-value对，key不可重复，value可以重复。（可以根据key访问）。可以把Set看成一个罐子，Set记不住添加元素的顺序，所以元素值不能重复；List像数组，用索引记住元素添加顺序，但是长度可变；Map也像罐子，但每个元素都是key-value对。 Collection和Iterator接口Collection集合是Set、List、Queue的父接口 遍历集合 使用Lambda表达式Java8为Iterable接口新增了一个forEach(Consumer action)方法，该方法的参数是个函数式接口，而Iterable接口是Collection的父接口，所以Collection可以直接调用forEach()方法，Consumer接口的唯一函数是accept(T t)，可以使用Lambda表达式如下： 12345678910public class Main &#123; public static void main(String[] args) throws Exception &#123; HashSet hs = new HashSet(); int[] a = &#123;1,2,3,4,5&#125;; for(int e: a) &#123; hs.add(e); &#125; hs.forEach(ele-&gt; System.out.println(ele)); &#125;&#125; 使用Iterator当使用Iterator迭代访问集合元素时，不能用集合自己的方法修改集合元素，可以用Iterator的remove()方法删除上一次next()方法返回的元素 123456789101112public class Main &#123; public static void main(String[] args) throws Exception &#123; HashSet hs = new HashSet(); int[] a = &#123;1,2,3,4,5&#125;; for(int e: a) &#123; hs.add(e); &#125; Iterator it = hs.iterator(); while(it.hasNext()) System.out.println(it.next()); &#125;&#125; 使用foreach 12345678910111213public class Main &#123; public static void main(String[] args) throws Exception &#123; HashSet hs = new HashSet(); int[] a = &#123;1,2,3,4,5&#125;; for(int e: a) &#123; hs.add(e); &#125; for(Object e: hs) &#123; System.out.println((Integer)e); &#125; &#125;&#125; Java8 PredicateJava8为Collection新增了一个removeIf(Predicate filter)方法，该方法会批量删除符合filter的元素。Predicate是个函数式接口，可以使用Lambda表达式重写它的test(T t) 1234567Collection books = new HashSet();books.add("大傻子");books.add("a");books.add("b");books.add("123");books.add("456");books.removeIf(ele-&gt; ((String)ele).length()&gt;2 ); //删除长度&gt;2的元素 Set集合Set集合与Collection集合基本相同，没有提供任何自己的方法。Set集合不允许包含相同元素，如果试图添加add()相同元素，则添加操作失败，add()返回false。 HashSetHashSet的特点： 不能保证元素顺序，顺序可能与添加顺序不同 HashSet不是同步的，如果多个线程同时访问一个HashSet，并同时修改了HashSet时，必须通过代码手动同步。 集合元素可以是null。需要注意HashSet判断元素是否相同时通过equals和hashCode LinkedHashSetLinkedHashSet是HashSet的子类，因为用链表维护了插入元素的顺序，因此性能略低于HashSet，但在迭代访问时性能较好 TreeSetTreeSet是SortedSet接口的实现类，可以确保元素处于排序状态。TreeSet是采用红黑树存储数据的。 自然排序TreeSet会调用集合元素的compareTo(Object o)方法比较元素大小排序，compareTo是TreeSet判断元素是否相等的唯一标准，compareTo的返回值是int类型，例如obj1.compareTo(obj2)，返回值等于0就判断元素相等，返回值大于0表明obj1&gt;obj2，小于0表示obj1 &lt; 0bj2 若一个类没有实现Comparable接口，在加入TreeSet时会报错 进行compareTo时，会把被比较的元素强制转换成相同类型，所以要求TreeSet中的元素都是同一类的实例 需要注意如果TreeSet中添加了一个可变对象，且后面的程序修改了可变对象的实例变量，导致大小顺序发生改变，TreeSet不会重新排序 List集合List集合代表有序、可重复的集合，集合的每个元素都有索引值，从0开始。注意，List判断两个对象相等的标准是equalsList额外提供了一个ListIterator()方法，返回一个ListIterator对象，增加了向前迭代的方法hasPrevious(),previous(),add(Object o) ArrayList和VectorArrayList和Vector是List的典型实现类，Vector年代久远不建议使用，（Vector是线程安全的，ArrayList线程不安全，但可以使用Collections工具类转变为安全的，还是不要使用Vector啦） QueueQueue用来模拟队列，有一个PriorityQueue实现类和Deque接口 PriorityQueu实现类这个类有点奇怪，会重新排序队列中的元素，如果想用队列还是使用下面的ArrayDeque Deque接口和ArrayDeque实现类Deque是Queue的子接口，是双端队列，所以可以当成队列使用，也可以当成栈，ArrayDeque是它的典型实现类 ArrayDeque作为栈使用 123456789101112public class Main &#123; public static void main(String[] args) throws Exception &#123; ArrayDeque stack = new ArrayDeque(); stack.push("JAVA"); stack.push("python"); stack.push("c++"); System.out.println(stack); // 输出[c++, python, JAVA] System.out.println(stack.peek()); //获取栈顶元素，不删除 ，输出 c++ stack.pop(); //弹出“C++” System.out.println(stack); //输出[python, JAVA] &#125;&#125; ArrayList作为队列使用 123456789101112public class Main &#123; public static void main(String[] args) throws Exception &#123; ArrayDeque queue = new ArrayDeque(); queue.offer("JAVA"); queue.offer("python"); queue.offer("c++"); System.out.println(queue); // 输出[JAVA, python, c++] System.out.println(queue.peek()); //获取队首元素，不删除 ，输出JAVA queue.poll(); //删除JAVA System.out.println(queue); //输出[python, c++] &#125;&#125; LinkedList实现类LinkedList是List的实现类，所以可以当List使用索引，还实现了Deque接口，所以可以当成双端队列 线性表性能分析Java提供的List就是一个线性表接口，ArrayList是基于数组的，LinkedList是基于链表的。数组在随机访问（通过下标访问）性能最好；而链表在插入删除时性能较好。总体来说ArrayList比LinkedList性能好一些，大部分时候建议使用ArrayList。 需要遍历：使用LinkedList时，采用迭代遍历（使用Iterator）：使用ArrayList时，按下标访问（使用get(int index）方法） 频繁插入删除：考虑使用LinkedList。插入删除操作频繁改变集合大小，使用ArrayList会经常重新分配数组大小，性能较差。 线程安全：如果需要线程安全，可以用Collections工具类包装成线程安全的集合。 MapMap保存具有映射关系的键值对，因此Map保存两组数据，一组存key一组存value。Map中的key值组成了一个Set集合，value相当于key的附属品，这样就可以把Map当成Set了；实际上Map提供了一个Entry内部类封装key-value对，计算存储时只需要考虑key。从Java源码来看，Java是先实现了Map，然后通过包装所有的value为null实现了Set。Map中key的集合像Set，而value的集合像List，不过此时的索引变成key了 Java8位Map新增的方法新增了一些方法，他们的参数是函数式接口，所以可以使用Lambda表达式，如下： HashMap和HashtableHashMap和Hashtable是Map的典型实现类，Hashtable是个古老的类，连名字都没有遵循规范，强烈不建议使用。HashMap中key值可以为null，但只有一个key能为null，因为key不允许重复；value值可以有多个null。HashMap中判断key是否相等的标准是hashCode和equals；判断value是否相等的标准是equals与HashMap相似，如果集合中key是可变对象，修改可变对象时会造成无法正确访问被修改的key，最好不要修改HashMap中的可变对象 LinkedHashMapLinkedHashMap是HashMap的子类，它维护了一个双向链表，所以可以保存插入顺序，且在迭代访问时有较好的性能，迭代时可以使用Java8为Map新增的forEach方法 123456789public class Main &#123; public static void main(String[] args) throws Exception &#123; LinkedHashMap scores = new LinkedHashMap(); scores.put("语文", 80); scores.put("数学", 100); scores.put("英语", 95); scores.forEach((key, value) -&gt; System.out.println(key+"--&gt;"+value)); &#125;&#125; 使用Properties读写属性文件Properties是Hashtable的子类，实例代码如下： SortedMap接口和TreeMap实现类TreeMap是SortedMap的实现类，也是采用红黑树实现，对key值排序时也是比较compareTo 各Map性能比较TreeMap比HashMap慢一些（在插入删除时更慢），但TreeMap有个好处是无需专门排序，TreeMap被填充后可以调用TreeSet获取key组成的Set，然后使用toArray()生成key的数组，然后使用Arrays的binarySearch()快速查询对象。一般场景下建议使用HashMap，因为HashMap正是为快速查询设计的。LinkedHashMap比Hashmap慢一点，因为需要维护链表。 工具类Collections排序、查找、替换123456789void reverse(List list);void shuffle(List lsit); //模拟洗牌void sort(List list);void swap(List list, int i, int j);void rotate(List list, int distance); //distance为正数时，将list的后distance个元素整体移到前面；distance为负，将前distance个元素后移。int binarySearch(List list, Object key); //必须保证list是有序集合Object max(Collection c);Object max(Collection c, Comparator comp); //根据指定的顺序排列boolean replaceAll(List list, Object oldValue, Object newValue); 同步使用synchronizedXxx()转变成线程安全的集合 1234567891011121314//CollectionCollection c = Collections.synchronizedCollection(new ArrayList);//List集合List list = new LinkedList();list=Collections.synchronizedList(list);//Set集合：Set&lt;String&gt; set=new HashSet&lt;String&gt;();set=Collections.synchronizedSet(set);//Map集合：Map&lt;String, Integer&gt; map=new HashMap&lt;String, Integer&gt;();map=Collections.synchronizedMap(map); 设置不可变集合emptyXxx(); //返回空的不可变集合，可以是Set、List、MapsingletonXxx(Object o); //返回只包含一个对象的不可变集合，可以是Set、List、MapunmodifiableXxx(Collection c); //返回指定集合的不可变集合，可以是Set、List、Map]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-疯狂Java讲义-第6章-Java基础类库]]></title>
    <url>%2F%E7%AC%94%E8%AE%B0-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC6%E7%AB%A0-Java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93%2F</url>
    <content type="text"><![CDATA[与用户互动 main函数参数main函数的参数是String[] args, 可以在运行时输入参数，每个参数之间用空格隔开。在命令行运行时，假如文件名为Test.java，参数设定为”LSK”和”dsz”，运行该程序的命令为java Test LSK dsz若使用eclipse，可以运行时点击右键Run as-&gt;Run Configurations，在arguments中输入参数，如下图 若参数中含有空格，可以吧参数用双引号括起来，若参数是a b，写成&quot;a b&quot; ScannerScanner类可以从文件、输入流、字符串中解析基本类型值和字符串值。Scanner提供多个构造器可以接收不同类型的数据源。Scanner主要提供了两个方法扫描输入： hasNextXxx() 是否含有下一个输入项 nextXxx() 获取下一个输入项 useDelimiter(String s) 参数可以是正则表达式，默认情况下以空白（空格、Tab、回车）作为输入项之间的分隔符，可以设置分隔符 使用Scanner(System.in)构造器可以从键盘读数据使用Scanner(new File(“filename.txt”))可以从文件读数据 注意文件地址\ /的区别和用法windows系统中的文件目录使用反斜杠\，其他操作系统一般使用正斜杠/，所以文件目录一般写”E:/test/testTxt.txt”，也可以写作”E:\\test\\testTxt.txt” 系统相关 System类System类代表Java程序的运行平台，System类提供了标准输入、输出、错误输出的类变量，还有一些环境变量和系统属性的访问。 1234System.getenv() //获取全部环境变量System.getenc("JAVA_HOME") //获取指定环境变量的值System.getProperties() //获取所有系统属性System.getProperty("os.name") //获取指定系统属性 访问时间 12System.currentTimeMillis() //获取1970-1-1到现在的毫秒数System.namoTime() //纳秒数，大多数操作系统不支持 返回对象的精确hash值 1System.identityHashCode(Object o) //根据对象的地址算出的hash值，若两个对象identityHashCode值相等，他们就是一个对象 System类还提供了gc()、runFinalization() Runtime类Runtime类也提供了gc()和runFinalization()Runtime是java运行时环境，每个Java程序有一个与之对应的Runtime实例，可以通过getRunTime()获取对象，可以访问JVM相关信息 1234Runtime rt = RunTime.getTunTime();rt.availableProcessors(); //处理器数量rt.freeMemory(); //空闲内存数rt.totalMemory(); //总内存数 Runtime类可以启动一个进程 12Runtime rt = RunTime.getTunTime();rt.exec("notepad.exe"); //打开记事本 常用类 ObjectObject是所有类的父类，（enum类的直接父类是java.lang.enum，但java.lang.enum继承Object，所以enum的父类也是Object）。Object类有如下方法： 12345boolean equals(Object o); //判断两个对象是否同一，和“==”作用相同，但很多类都重写了equalsprotected void finalize(); //当系统中没有引用指向该变量，垃圾回收器调用该方法清理该对象的资源Class&lt;?&gt; getClass(); //返回该对象的运行时类int hashCode(); //根据对象地址计算hashCode，与System.identityHashCode值相同，但很多类重写了hashCode方法。String toString(); //当系统使用System.out.println()输出一个对象或把对象和字符串连接时，系统自动调用该方法，返回`运行时类名@hashCode值`，但很多类也重写了该方法 Object的clone方法void clone(Object o)，实现自我克隆，得到一个该对象的副本，需要注意这只是一种浅复制，只复制成员变量的值，不会对引用类型的成员变量所指的对象克隆，如图所示： Objects检验空指针异常，如果一个引用为空，调用他的toString()会引发NullPointException，可以使用Objects.toString(Object o)，此时若o为空，返回字符串”null” 1Objects.hashCode() //null对象输出0 使用Objects.requireNonNull()方法检验参数是否为null，如下 String、StringBuffer、StringBuilderString是不可变类，StringBuffer和StringBuilder功能相似，但StringBuffer是线程安全的，StringBuilder因为没有线程安全所以速度更快。String有一些重要的方法， 1234567891011121314151617String(bytes[] bytes, Charset charset) //使用指定字符集解码成字符串String(bytes[] bytes, int offset, int length, String charsetName) //从bytes数组offset位开始，长度为length的子数组，以charsetName的编码方式，建立字符串String(char[] val, int offset, int count) //从字符数组offset位开始，创建长度为count的字符串int lenght()char charAt(int index) //返回下标为index的字符int indexOf(char ch) String indexOf(String str)int lastIndexOf(char ch)String concat(String s) //将String对象与s拼接在一起，和“+”功能相同boolean equals(String s) //字符串序列相同则返回truebytes[] getBytes() void getChars(int srcBegin, int lenth, Char[] dst, int dstBegin) //将原对象src从srcBegin开始，长度为length位，赋值给dst数组，从dstBegin开始复制 String replace(char old, char new) //替换第一个 String subString(int start, int end) 因为String类对象不可变，所以会额外产生很多临时变量，使用StringBuilder或StringBuffer可以避免，StringBuilder和StringBuffer有两个属性length和capacity，以下是StringBuilder的方法，StringBuffer一样 Math不写了(；д；) Random和ThreadLocalRandom 1234Random r = new Random() //参数是种子，一样的种子生成的随机数相同，一般使用System.currentTimeMillis做种子r.nextInt() //生成随机intr.nextInt(26) //0~26r.nextDouble() //0.0~1.0 BigDecimal Java8 日期时间类 Date不建议使用，设计的不好 CalendarCalendar是个抽象类，所以可以通过Calendar c = Calendar.getInstance()获取实例 注意set MONTH的时候，MONTH是以0开始的。 * add、roll的区别 add会进位，roll不进位，如果下一级字段需要改变，会自动修正到改变最小的数。 ![](https://raw.githubusercontent.com/Whisper912/pic/master/%E7%AC%94%E8%AE%B0-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC6%E7%AB%A0-Java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93/add%E3%80%81roll.png) * 容错 使用set设置时，有可能出现不合法的数值，自动修正。可以使用`Calendar.setLenient(false)`关闭容错 12Calendar c = Calendar.getInstance()c.set(MONTH,13); //结果是YEAR+1，MONTH字段是1（2月） * set延时 ![](https://raw.githubusercontent.com/Whisper912/pic/master/%E7%AC%94%E8%AE%B0-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC6%E7%AB%A0-Java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93/set%E5%BB%B6%E6%97%B6.png) java.time包我懒得写啦o(╥﹏╥)o Java8 日期、时间格式器 DateTimeFormatter]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-疯狂Java讲义-第5章-面向对象（下）]]></title>
    <url>%2F%E7%AC%94%E8%AE%B0-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC5%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java8增强的包装类 包装类和字符串相互转换 包装类的parseXxx(String s) 12Integer i=Integer.parseInt("1223");System.out.println(i); //输出1223 包装类的Xxx(String s)构造器 12Integer i = new Integer("123");System.out.println(i); //输出123 String类的多个重载valueOf(), 将boolean、int、double、float、Object、char类型的参数转变为String类型 1String s=String.valueOf(2.4); //将double类型的2.4转化成String 包装类的compare(xxx val1, xxx val2) 1Integer.compare(int a, int b) //a&gt;b则返回1，a&lt;b返回-1，相等返回0 对象的比较 equalsString重写了Object的equals方法，当两个字符串的内容相同时，就返回true。而“==”是比较值是否相等。c和cc里存的是实例的地址，地址不相等。1234String c="abc";String cc=new String("abc");System.out.println(c.equals(cc)); //trueSystem.out.println(c==cc); //false 类成员用static修饰的就是类成员，static不能修饰构造器。类成员变量在类第一次被加载时就分配空间。 final修饰符final修饰的变量一旦被附了初值就不能改变。 成员变量final成员变量必须显式赋初值 局部变量局部变量系统不会自动赋初值，必须由程序员显式初始化 引用变量final修饰引用变量时，因为引用变量存的是地址，及地址一旦被赋值就不能改变，但是可以改变引用所指的地址的值。 宏替换若final变量在定义时就被附了初始值，且该初始值在编译时可以被确定，此时的final变量相当于一个直接量，编译器会把所有用到该变量的地方替换成值。 final方法final方法不可被重写 final类final修饰的类不能有子类。 抽象类抽象类定义的是一种模板 使用abstract修饰符，若类中有抽象方法，这个类只能被定义成抽象类；抽象类里可以没有抽象方法。 抽象类没有方法体 抽象类不能被实例化，不能使用new创建抽象类实例 Java8改进的接口接口定义的是一种规范，所以没有构造器和初始化块，接口里所有成员都是public权限，接口里的成员变量只能是静态常量（public static final），成员方法只能是抽象方法或者默认方法（default） 接口的继承可以继承多个接口 接口的实现 1234interface Product&#123;&#125;class Printer implements Product &#123;&#125;Product p = new Printer(); 内部类内部类的作用是： 更好的封装性 内部类可以直接访问外部类的private数据 匿名内部类适合创建只使用一次的类 非静态内部类，就是在类的内部定义一个非静态类成员变量，非静态内部类可以直接访问外部类的private成员 需要注意的是，非静态内部类在创建实例时会保存一个外部类对象的引用，如下： 静态内部类静态内部类只能访问外部类的静态成员，静态内部类的实例也不能访问外部类的实例成员 使用内部类使用非静态内部类时：1Out.In in = new Out().in(); //非静态内部类的构造器必须由外部类的对象调用 使用静态内部类“ 1Out.In in = new Out.In(); Java8改进的匿名内部类创建匿名内部类时会创建一个匿名内部类的实例，这个类的定义会立即消失，不能重复使用。匿名内部类必须继承一个父类或者实现一个接口。 Java8新增的lambda表达式Lambda表达式和匿名内部类的区别： 匿名内部类可以为任何接口创建实例，Lambda表达式只能为函数式接口创建实例 匿名内部类可以为抽象类甚至普通类创建对象；Lambda只能为函数式接口创建实例 匿名内部类实现的抽象方法体中允许调用接口中的默认方法；Lambda不行 枚举类默认继承java.lang.enum 123enum Season &#123; SPRING, SUMMER, FALL, WINTER&#125; 使用时Season.SPRING]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-疯狂Java讲义-第4章-面向对象（上）]]></title>
    <url>%2F%E7%AC%94%E8%AE%B0-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[类和对象 static修饰的成员变量和方法是属于类的，可以直接用类名.成员变量/方法名调用，Java也允许实例调用static修饰的类成员变量/方法，但这是不合理的；static修饰的成员不能访问没有static的成员 对象是一种引用类型，真正的对象在堆中存放，定义一个Person p = new Person(); //Person类有两个成员变量name和age，内存示意图如下，引用变量中存的是实际对象的地址。 this指向调用该方法的对象，一般用于让类中的一个方法调用其他方法或实例变量static修饰的成员是属于类的，所以不能使用this。 方法详解 方法的参数传递机制：Java中是参数是值传递，引用类型也是，引用类型变量的值是一个地址 参数个数可变的方法，定义时使用如下格式void name(String... string) 重载：方法的重载是说在一个类中的方法方法名相同，参数类型/个数不同。 成员变量和局部变量 成员变量初始化和内存中的运行机制系统加载类或创建实例时，会自动为成员变量分配空间并自动指定初值 局部变量初始化和内存中的运行机制局部变量在定义后必须显式初始化才能使用，赋初值时系统才为局部变量分配空间，分配在函数的栈空间中，函数执行完后，随着函数栈一起被销毁。 大规模使用成员变量坏处 成员变量生存周期长，一直待在内存中，占用空间 成员变量作用域广，不利于高内聚 隐藏和封装封装是将对象内部信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过类所提供的接口来访问操作。 访问控制符：private(类访问权限) &lt; default(包访问权限) &lt; protected(子类访问权限) &lt; public(公共访问权限) package ：如果没有导入包，调用其他包的类是必须写类的全称，使用import导入包后就不必写类的全名了；import static导入类的static成员和方法。 深入构造器构造器的作用是在创建实例时初始化实例，要注意不是构造器全部负责创建实例，在用new调用构造器时，系统先为实例分配空间，并默认初始化（int型为0，引用类型为null），然后才开始执行构造器中的初始化操作。 构造器重载：构造器中也可以使用this 类的继承Java用extends关键字来继承，翻译成扩展更好，子类是特殊的父类，是对父类的扩展。Java没有多继承，即每个类只有一个直接父类（但可以有间接父类）。 重写：子类的方法与父类同名，参数列表也相同，且都为实例方法或都为类方法 super：子类中要调用被覆盖的父类方法或成员变量可以使用super 调用父类构造器：子类不会继承父类的构造器，但可以通过super调用，不管是否使用super，构建子类对象时都会调用父类构造器 多态Java引用变量有两个类型，编译时类型和运行时类型。编译时类型是声明该变量时使用的类型，运行时类型是由赋给变量的实际对象决定的。两个类型不一样就可能出现多态。相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。 instanceof：前操作数是引用类型，后操作数是类/接口，用于判断前面的对象是否是后面的类或子类的实例 初始化块用{}括起来，先执行初始化块后执行构造器。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-疯狂Java讲义-第3章-流程控制与数组]]></title>
    <url>%2F%E7%AC%94%E8%AE%B0-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC3%E7%AB%A0-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[顺序结构、选择结构、循环结构需要注意的点如下： switch语句后面的表达式可以为byte，int，short，char，从Java7开始允许String（java.lang.String）和枚举类型enum，不能是boolean。 Java不支持goto语句 Java中可以用标签标识外层循环（Java中的标签是标识符后紧跟冒号（:）)，然后使用’break 标签名’直接跳出外层循环，或’continue 标签名’终止本次外层循环，通常将标签定义在外层循环外。以下为示例代码：123456789101112public class Test &#123; public static void main(String[] args) &#123; outer: //定义一个outer标签 for(int i=0; i&lt;3; i++) &#123; for(int j=0; j&lt;5; j++) &#123; if(j==2) continue outer; //直接跳出本次外轮循环 System.out.println("i="+i+" j="+j); &#125; &#125; &#125;&#125; 程序输出结果为 123456i=0 j=0i=0 j=1i=1 j=0i=1 j=1i=2 j=0i=2 j=1 数组可以把数组当做是一种新类型，数组实际上是引用（指针），所以定义数组时最好使用如int[] a，可以解释为定义了一个int[]类型的变量a 数组初始化 静态初始化——只给出数组元素的值，由编译器自动确定长度 1234int[] a;a=new int[]&#123;1,2,3,4&#125;;String[] b = new String[]&#123;"喜欢你","大傻子","李式焜"&#125;; 动态初始化——只给出数组长度，由编译器自动分配默认值（int型为0，float/double为0.0，char型为’\u000,’，引用类型如String为null） 12String[] s = new String[4];s[1] = "李式焜大傻子"; 数组访问数组有一个length属性，可以获取数组长度 12int a = new int[5];System.out.println(a.length); //输出 5 foreach循环（Java5java为数组提供了foreach循环，但注意不要在foreach循环中试图修改数组元素的值 123456String[] b = new String[]&#123;"喜欢你","大傻子","李式焜"&#125;; //将会输出 喜欢你 大傻子 李式焜 for(String s: b) &#123; //这里String s是定义了一个形参，b是数组名 System.out.print(s+" "); &#125;//最后输出结果为 喜欢你 大傻子 李式焜 12345String[] b = new String[]&#123;"喜欢你","大傻子","李式焜"&#125;; for(String s: b) &#123; //这里String s是定义了一个形参，b是数组名 s="你好";&#125;System.out.print(b[0]); //这里将会输出 喜欢你，因为s是形参，只修改了形参的值，真正的b并没有被修改！ 多维数组？Java中实际没有多维数组，例如定义一个二维数组int[][]a,实际上是定义了一个int[] 一维数组，每个数组元素又是一个int[]的一维数组 1String[][] str2 = new String[][]&#123;new String[3], new String[]&#123;"hello"&#125;&#125;; Java8工具类：ArraysArrays类中的一些方法如下，使用 Arrays类时需要import java.util.Arrays type binarySearch(type[] a, type key) 二分法查找元素值为key的元素的下标，注意当数组是有序的才得到正确结果 type binarySearch(type[] a, int from, int to, type key) void sort(type[] a) 升序排序数组元素 void sort(type[] a, int from, int to) void fill(type[] a, type val) 将a所有元素赋值val void fill(type[] a, int from, int to, type val) type[] copyOf(type[] original, int length) 把original数组复制到一个新数组，length是新数组长度 type[] copyOfRange(type[] original, int from, int to) 只复制下标从from到int的元素 boolean equals(type[] a, type[] b) a和b数组长度相等且元素一一相同，返回true。 String toString(type[] a) 将数组转换成一个字符串如[1,2,大傻子]]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-疯狂Java讲义-第2章-数据类型和运算符]]></title>
    <url>%2F%E7%AC%94%E8%AE%B0-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC2%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Java是强类型语言。强类型包含两方面含义： 所有变量必须先声明后使用。 指定类型变量只能接受类型与之匹配的值。 注释Java有三种类型的注释： 单行注释。//这是单行注释 多行注释。 12/*这是多行注释这是多行注释*/ 文档注释。 12345/***这里是文档注释*@author*@version*/ 文档注释是用于生成API文档的，API文档是用于说明类、方法、成员变量的功能。文档注释可以用javadoc工具处理成API文档，并且javadoc工具默认只处理以public或protected修饰的类、接口、方法、成员变量、构造器、内部类之前的文档注释。javadoc命令的选项可以通过javadoc -help查看。 标识符和关键字Java标识符由字母、下划线（_）、美元符（$）开头，后面可以跟任何数目的字母、数字、下划线、美元符，区分大小写。标识符不能是关键字和保留字，但可以包含关键字和保留字。Java还有三个特殊的直接量（literal）：true、false、null，标识符也不能是这三个直接量。Java有50个关键字，Java关键字都是小写的，如下图。 基本数据类型 数值中使用下划线Java7开始，可以在数值中使用下划线，不论是整型数值还是浮点型数值。double pi = 3.14_15_92_65_36 整型 所有数字在计算机底层都是二进制形式存在。原码是直接将一个数换算成二进制数。计算机以补码形式保存所有整数。补码的计算规则是：正数补码与原码相等，负数的补码是原码的反码加1（反码是除了符号位，按位取反）。 整数默认是int型，使用二进制定义整数时，二进制整数默认占32位，第32位是符号位；如果在二进制整数后加字母L/l，二进制整数被认为是long型，占64位，第64位是符号位。如下图举例： 浮点型 java默认浮点类型数值是double，在其后加F/f可变为float。 boolean型boolean的值只能是true或false，不能用0和非0表示，其他基本数据类型的值也不能转换成boolean型。字符串”true”和”false”不能直接转换成Boolean型，但boolean类型和字符串连接可以将boolean类型的值转换成字符串。String str = true + &quot;&quot;; 强制类型转换 算数表达式的自动提升 运算符 赋值表达式的值是等号右边的值。 位运算符 左移（&lt;&lt;）运算符是将操作数的二进制码整体左移指定位，右边补0. 右移（&gt;&gt;）是左边空出来的位填符号位（正数填0，负数填1）。 无符号右移（&gt;&gt;&gt;）左边空位填0。 逻辑运算符||(或)和|(不短路或)，不短路或（|）前后两个操作数都会计算，不短路与（&amp;）同。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-疯狂Java讲义-第1章概述]]></title>
    <url>%2F%E7%AC%94%E8%AE%B0-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC1%E7%AB%A0%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[【写在前面】以下内容来自于本人对《疯狂Java讲义精粹》的摘录总结，主要摘录了自己觉得重要/不熟悉的内容，供自己参考学习，如有断章取义的地方还请包容。(❁´◡`❁)✲ﾟ 《疯狂Java讲义 精粹》 第1章 Java概述和环境Java发展史略(～￣▽￣)～ Java运行机制高级语言运行机制高级语言按程序执行方式可分为编译型和解释型。 编译型语言是指用专门的编译器， 针对特定平台将高级语言一次性翻译成可被该平台硬件执行的机器码，并包装成该平台可识别的可执行程序。（如C，C++ 解释型语言是使用专门的解释器对源程序逐行解释成特定平台机器码并立即执行。（如Python， Ruby Java程序运行机制和JVM（Java Virtual Machine)Java程序执行必须经过先编译、后解释两个步骤，如图 Java中负责解释执行字节码文件(*.class文件)的是Java虚拟机, 即JVM(Java Virtual Machine)。当使用Java编译器编译Java程序时，生成的是与平台无关的字节码，这些字节码不面向任何平台，只面向JVM。不同的平台上JVM都不同，但都提供了相同的接口。 JVM是个抽象的计算机, 和实际计算机一样，具有指令集并使用不同的存储区域。它负责执行指令，还要管理数据、内存和寄存器。Oracle指定的JVM统一标准，具体定义了JVM的如下细节：指令集、寄存器、类文件的格式、栈、垃圾回收堆和存储区。 配置Java开发环境JDK（Java SE Development Kit），即Java标准版开发包，是开发Java应用程序的发开包，提供了编译、运行Java程序的各种工具和资源，包括Java编译器、Java运行时环境（JRE，Java Runtime Environment）以及常用Java类库。JRE中包含了JVM。安装过程略。 Hello World新建记事本文本文件（不要使用写字板，Windows可使用NotePad），文件名为HelloWorld.java，并输入如下代码，注意区分大小写 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("Hello World"); &#125;&#125; 可在命令行中进入当前文件路径，输入javac -d . HelloWorld.java编译程序；输入java HelloWorld运行。 Java程序基本规则Java程序是纯粹的面向对象语言，因此Java程序必须以类（class）的形式存在，类是Java程序的最小程序单元。Java程序不允许可执行语句、函数独立存在，所有程序部分必须放在类定义里。最简单的Java程序是一个包含空类定义的程序， 如 123class Test&#123;&#125; 这个类可编译但不能解释执行，因为Java解释器规定：若某个类能被解释器执行，则这个类必须包含main方法，且main方法必须用public static void来修饰，且main的参数必须是字符串数组类型（String[] args)。【注意】：一个Java源文件可以包含多个类定义，但最多只能包含一个public类定义；如果Java源文件里包含public类定义，则该文件的文件名必须与这个public类的类名相同。 不建议新手使用IDE]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李式焜大傻子]]></title>
    <url>%2F%E6%9D%8E%E5%BC%8F%E7%84%9C%E5%A4%A7%E5%82%BB%E5%AD%90%2F</url>
    <content type="text"><![CDATA[我最喜欢李式焜啦！ღ( ´･ᴗ･` )比心]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>李式焜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FHello%20World%2F</url>
    <content type="text"><![CDATA[以下为测试内容 标题1标题2标题3这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); Red Green Blue This is an example inline link. This link has no title attribute. unfriggingbelievable Use the printf() function. System.out.println() 1代码块]]></content>
  </entry>
</search>
